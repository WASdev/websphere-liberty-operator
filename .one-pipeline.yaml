version: "1"

setup:
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    echo "setup"
    wget --header "Accept: application/octet-stream"  "https://golang.org/dl/go1.16.linux-amd64.tar.gz"
    export PATH=$PATH:/usr/local/go/bin
    apt-get update
    apt-get -y install build-essential
    rm -rf /usr/local/go && tar -C /usr/local -xf go1.16.linux-amd64.tar.gz
    go mod vendor

    ENABLE_BRANCH_PROTECTION=$(get_env enable-branch-protection)
    BRANCH=$(get_env branch)

    # Only enable branch protection on branches that are not "main" or a patch branch (e.g. 1.1.x)
    if [[ "$ENABLE_BRANCH_PROTECTION" == "true" && "$BRANCH" != "main" && ! "$BRANCH" =~ [0-9](.[0-9])?.x ]]; then
      GH_TOKEN=$(get_env git-public-token)
      REPO=$(get_env app-repo)
      REPO="$(echo ${REPO%.git} | sed 's/https:\/\/github.com\///')"

      echo "REPO: $REPO"
      echo "BRANCH: $BRANCH"

      # Commenting this out because it "locks" whatever branch you're building and prevents pushes to it. This is good for a main branch, 
      # but not for dev branches. This means that the branch-protection check will fail. 
      # curl -u :$GH_TOKEN https://api.github.com/repos/$REPO/branches/$BRANCH/protection -H "Accept: application/vnd.github.v3+json" -X PUT -d '{"required_pull_request_reviews":{"dismiss_stale_reviews":true,"required_approving_review_count":1},"enforce_admins":null,"restrictions":null,"required_status_checks":null}'
    fi

    // Update repo with Whitesource enabled
    GHE_TOKEN=$(get_env git-token)
    WHITESOURCE_GHE_REPO=$(get_env whitesource-ghe-repo | sed 's/https:\/\///')
    BRANCH_REFSPEC="+refs/remotes/origin/$BRANCH:refs/heads/$BRANCH"

    if [[ -n "$(git branch --list -r origin/$BRANCH)" ]]; then
      echo "Pushing branch $BRANCH to $WHITESOURCE_GHE_REPO"
    elif [[ -n "$(git tag --list $BRANCH)" ]]; then
      echo "The given 'branch' ($BRANCH) is a tag. Pushing only tags to $WHITESOURCE_GHE_REPO."
      BRANCH_REFSPEC=""
    else
      echo "Warning: Could not find a matching branch or tag named '$BRANCH'. Trying anyway!"
    fi

    echo "git push --prune https://$GHE_TOKEN@$WHITESOURCE_GHE_REPO $BRANCH_REFSPEC +refs/tags/*:refs/tags/*"
    git push --prune https://$GHE_TOKEN@$WHITESOURCE_GHE_REPO $BRANCH_REFSPEC +refs/tags/*:refs/tags/*

test:
  dind: true
  abort_on_failure: true
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash

    ## Setup required tooling
    wget --header "Accept: application/octet-stream"  "https://golang.org/dl/go1.16.linux-amd64.tar.gz" 
    rm -rf /usr/local/go && tar -C /usr/local -xf go1.16.linux-amd64.tar.gz
    export PATH=$PATH:/usr/local/go/bin
    apt-get update
    apt-get -y install build-essential

    make unit-test

static-scan:
  dind: true
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    read -r SONAR_HOST_URL <<< "$(get_env sonarqube | jq -r '.parameters.dashboard_url' | sed 's:/*$::')"
    read -r SONAR_USER <<< "$(get_env sonarqube | jq -r '.parameters.user_login')"
    SONARQUBE_INSTANCE_ID=$(get_env sonarqube | jq -r '.instance_id')
    read -r SONAR_PASS <<< "$(jq -r --arg sonar_instance "$SONARQUBE_INSTANCE_ID" '[.services[] | select(."service_id"=="sonarqube")][] | select(."instance_id"==$sonar_instance) | .parameters.user_password' /toolchain/toolchain.json)"  
    touch "$WORKSPACE"/websphere-liberty-operator/sonar-project.properties   
    cat << EOF > "$WORKSPACE"/websphere-liberty-operator/sonar-project.properties
    sonar.projectKey=websphere-liberty-operator
    sonar.host.url=$SONAR_HOST_URL
    sonar.sources=.
    sonar.login=$SONAR_USER
    sonar.password=$SONAR_PASS
    sonar.c.file.suffixes=-
    sonar.cpp.file.suffixes=-
    sonar.objc.file.suffixes=-
    EOF
    chmod -x "$WORKSPACE"/websphere-liberty-operator/sonar-project.properties
    #echo "$SONAR_PASS" >> /tmp/sonarqube-token
    "${COMMONS_PATH}"/static-scan/run.sh

    ## Perform static lint
    ./scripts/pipeline/static-linter-scan.sh --git-token $(get_env git-token) --static-linter-version $(get_env static-linter-version)

containerize:
  dind: true
  abort_on_failure: true
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    if [[ "$PIPELINE_DEBUG" == 1 ]]; then
      trap env EXIT
      env
      set -x
    fi

    # Download and configure golang
    wget --header "Accept: application/octet-stream"  "https://golang.org/dl/go1.16.linux-amd64.tar.gz"
    rm -rf /usr/local/go && tar -C /usr/local -xf go1.16.linux-amd64.tar.gz
    export PATH=$PATH:/usr/local/go/bin
    apt-get update
    apt-get -qq -y install build-essential software-properties-common uidmap

    # Download and install skopeo
    if ! command -v skopeo &> /dev/null; then
      if [ ! -f "/apt/sources.list.d/devel:kubic:libcontainers:stable.list" ]; then
        sudo sh -c "echo 'deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_18.04/ /' > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list"
        wget --no-check-certificate -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_18.04/Release.key -O- | sudo apt-key add -
        sudo apt-get update -qq
      fi
      sudo apt-get -y install skopeo
    else
      skopeo --version
    fi

    #  Build images
    export PIPELINE_USERNAME=$(get_env ibmcloud-api-user)
    export PIPELINE_PASSWORD=$(get_env ibmcloud-api-key-staging)
    export PIPELINE_REGISTRY=$(get_env pipeline-registry)
    export PIPELINE_PRODUCTION_IMAGE=$(get_env pipeline-production-image)
    export PIPELINE_OPERATOR_IMAGE=$(get_env pipeline-operator-image)
    export RELEASE_TARGET=$(get_env branch)
    export DOCKER_USERNAME=$(get_env docker-username)
    export DOCKER_PASSWORD=$(get_env docker-password)
    export REDHAT_USERNAME=$(get_env redhat-user-id)
    export REDHAT_PASSWORD=$(get_env redhat-password)
    export REDHAT_BASE_IMAGE=$(get_env redhat-base-image)
    export REDHAT_REGISTRY=$(get_env redhat-registry)
    export OPM_VERSION=$(get_env opm-version)

    # Build amd64 image
    make build-pipeline-releases

    # Build ppc64le and s390x images
    # Disabled for Liberty Operator builds for now
    #./scripts/pipeline/launch-travis.sh -t $(get_env travis-token) -r "https://github.com/WASDev/websphere-liberty-operator" -b $(get_env branch) -l

    # Build manifest
    make build-pipeline-manifest

    # Build bundle image
    make setup
    make bundle-pipeline

    # Build catalog image
    echo "${DOCKER_PASSWORD}" | docker login "${PIPELINE_REGISTRY}" -u "${DOCKER_USERNAME}" --password-stdin
    echo "${REDHAT_PASSWORD}" | docker login "${REDHAT_REGISTRY}" -u "${REDHAT_USERNAME}" --password-stdin
    make catalog-pipeline-build
    make catalog-pipeline-push

    # Save artifacts
    ## disabled the ppc64le and s380x save for now (see build stanza above).  Once these are built, we can move forward with this section.
    # declare -a tags=("${RELEASE_TARGET}" "${RELEASE_TARGET}-amd64" "${RELEASE_TARGET}-ppc64le" "${RELEASE_TARGET}-s390x")
    echo "**** Saving Artifacts ****"
    declare -a tags=("${RELEASE_TARGET}" "${RELEASE_TARGET}-amd64")
    for i in "${tags[@]}"
    do
      IMAGE=$PIPELINE_REGISTRY/$PIPELINE_OPERATOR_IMAGE:$i
      DIGEST="$(skopeo inspect docker://$IMAGE | grep Digest | grep -o 'sha[^\"]*')"
      { ARCH="$(echo $i | grep -o '\(amd64\|s390x\|ppc64le\)$')" && MANIFEST=false; } || { ARCH="amd64" && MANIFEST=true; }
      echo "Saving artifact operator-$i name=$IMAGE digest=$DIGEST manifest=$MANIFEST"
      save_artifact operator-$i type=image name="$IMAGE" "digest=$DIGEST" "arch=$ARCH" "manifest=$MANIFEST"
    done

    declare -a bundles=("${RELEASE_TARGET}")
    for i in "${bundles[@]}"
    do
     IMAGE=$PIPELINE_REGISTRY/$PIPELINE_OPERATOR_IMAGE-bundle:$i
     DIGEST="$(skopeo inspect docker://$IMAGE | grep Digest | grep -o 'sha[^\"]*')"
     #ARCH="$(echo $i | grep -o '\(amd64\|s390x\|ppc64le\)$' || echo 'amd64')"
     ARCH=amd64
     echo "Saving artifact bundle-$i name=$IMAGE digest=$DIGEST manifest=false"
     save_artifact bundle-$i type=image name="$IMAGE" "digest=$DIGEST" "arch=$ARCH" "manifest=false"
    done

    declare -a catalogs=("${RELEASE_TARGET}")
    for i in "${catalogs[@]}"
    do
     IMAGE=$PIPELINE_REGISTRY/$PIPELINE_OPERATOR_IMAGE-catalog:$i
     DIGEST="$(skopeo inspect docker://$IMAGE | grep Digest | grep -o 'sha[^\"]*')"
     #ARCH="$(echo $i | grep -o '\(amd64\|s390x\|ppc64le\)$' || echo 'amd64')"
     ARCH=amd64
     echo "Saving artifact catalog-$i name=$IMAGE digest=$DIGEST manifest=false"
     save_artifact catalog-$i type=image name="$IMAGE" "digest=$DIGEST" "arch=$ARCH" "manifest=false"
    done

sign-artifact:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/image-signing:1.0.0@sha256:e9d8e354668ba3d40be2aaee08298d2aa7f0e1c8a1829cca4094ec93830e3e6a
  script: |
    #!/usr/bin/env bash
    echo "sign-artifact"

deploy:
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    if [[ "$PIPELINE_DEBUG" == 1 ]]; then
      trap env EXIT
      env
      set -x
    fi
    echo "deploy"

dynamic-scan:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    echo "dynamic-scan"
    #export APP_URL=$(cat ../app-url)
    # feature preview this until evidence locker v2 usage is full feature ready
    # can be triggered, and owasp will run for preview purposes
    #source scripts/zap/trigger_api_scan.sh

acceptance-test:
  dind: true
  abort_on_failure: true
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    echo "acceptance-test"
    # Download and configure golang
    wget --header "Accept: application/octet-stream"  "https://golang.org/dl/go1.16.linux-amd64.tar.gz"
    rm -rf /usr/local/go && tar -C /usr/local -xf go1.16.linux-amd64.tar.gz
    export PATH=$PATH:/usr/local/go/bin
    apt-get update
    apt-get -y install build-essential
    export PIPELINE_USERNAME=$(get_env ibmcloud-api-user)
    export PIPELINE_PASSWORD=$(get_env ibmcloud-api-key-staging)
    export PIPELINE_REGISTRY=$(get_env pipeline-registry)
    export PIPELINE_OPERATOR_IMAGE=$(get_env pipeline-operator-image)
    export DOCKER_USERNAME=$(get_env docker-username)
    export DOCKER_PASSWORD=$(get_env docker-password)
    export CLUSTER_URL=$(get_env test-cluster-url)
    export CLUSTER_USER=$(get_env test-cluster-user kubeadmin)
    export CLUSTER_TOKEN=$(get_env test-cluster-token)
    export TRAVIS_BUILD_NUMBER=$BUILD_NUMBER
    export RELEASE_TARGET=$(get_env branch)
    export CATALOG_IMAGE="$PIPELINE_REGISTRY/$PIPELINE_OPERATOR_IMAGE-catalog:$RELEASE_TARGET"
    make setup
    make test-pipeline-e2e

scan-artifact:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.6@sha256:7f588468622a981f89cf5e1212aaf75fface9da6169b5345ca52ab63d8215907
  script: |
    #!/usr/bin/env bash
    echo "twistlock-scan"
    ./scripts/pipeline/twistlock-scan.sh
    echo "VA scan"
    . scripts/pipeline/va_scan
    if which list_artifacts >/dev/null; then
      list_artifacts | while IFS= read -r artifact; do
        image="$(load_artifact "$artifact" "name")"
        type="$(load_artifact "$artifact" "type")"
        digest="$(load_artifact "$artifact" "digest")"
        manifest="$(load_artifact "$artifact" "manifest")"
        name="$(echo "$artifact" | awk '{print $1}')"
        if [[ "$type" == "image" ]]; then
          if [[ "$image" == *"icr.io"* && "$manifest" == false ]]; then
            echo "Starting VA scan for $image"
            start_va_scan "$name" "$image" "$digest"
          else
            echo "Skipping VA scan for $image"
          fi
        fi
      done
    fi

    echo "aqua scan"
    # install docker
    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    # get aqua scan executables
    git clone https://$(get_env git-token)@github.ibm.com/CICD-CPP/cpp-pipelines.git
    chmod -R +x cpp-pipelines
    # setup and execute aqua scan
    cd cpp-pipelines
    export CUSTOM_SCRIPTS_PATH=/workspace/app/one-pipeline-config-repo/cpp-pipelines
    ./commons/aqua/aqua-local-scan

release:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash

    SKIP_ALL_CHECKS=$(get_env SKIP_ALL_CHECKS "false")
    ./scripts/pipeline/evaluator.sh      
    if [[ $? == 0 || $SKIP_ALL_CHECKS == "true" ]]; then
      if [[  $SKIP_ALL_CHECKS == "true" ]]; then
        echo "Skipping image scan checks"
      fi
      APP_REPO=$(pwd)
      echo "Application Repository: $APP_REPO"
      # export GIT_AUTH_USER=${GIT_AUTH_USER}
      INVENTORY_REPO=$(get_env inventory-repo)       
      echo "Cloning inventory repository: $INVENTORY_REPO"
      cd "$WORKSPACE"
      APP_TOKEN_PATH="$WORKSPACE/secrets/app-token"
      . "${ONE_PIPELINE_PATH}"/git/clone_repo \
        "$INVENTORY_REPO" \
        "master"  \
        "" \
        "$APP_TOKEN_PATH" 
      REPO=${INVENTORY_REPO##*/} 
      NAME=${REPO%.*}
      echo "Inventory name: $NAME"
      cd $WORKSPACE/$NAME
      if [ "$(ls )" ]; then
        echo "Clearing inventory repository: $INVENTORY_REPO"
        git config --global user.email "tekton@example.com"
        git config --global user.name "Tekton"
        git rm *
        git commit -m "Delete contents of inventory repository - $PIPELINE_RUN_ID"
        git push origin master
      fi
      cd $APP_REPO   
      ./scripts/pipeline/release.sh
    else
      echo "Errors found.  images will not be released"
    fi
